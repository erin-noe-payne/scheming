{"version":3,"sources":["Scheming.coffee"],"names":[],"mappings":"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","file":"Scheming.js","sourceRoot":"/source/","sourcesContent":["# # Annotated Source\n\n# Support node.js or browser environments\nroot = @\n\nisNode = typeof exports != 'undefined' && typeof module != 'undefined' && module.exports\n\n# Depends on lodash\nif isNode\n  _ = require 'lodash'\nelse\n  _ = window._\n\n# Uuid generator for anonymous Schema ids\nuuid = ->\n  now = Date.now()\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace /[xy]/g, (c) ->\n    r = (now + Math.random() * 16) % 16 | 0\n    now = Math.floor now / 16\n    ((if c is \"x\" then r else (r & 0x3 | 0x8))).toString 16\n\n# ## Scheming\n\n# ### DEFAULT_OPTIONS\n# Default options for `Schema.create`\nDEFAULT_OPTIONS =\n  seal   : false\n  strict : false\n\n# ### TYPES\n###\n  Scheming exports the default types that it uses for parsing schemas. You can extend with custom types, or\n  override the identifier / parser functions of the default types. A custom type should provide:\n   - ctor (optional) - Used in schema definitions to declare a type. `Scheming.create name : String`\n   - string - Used in schema definitions to declare a type. `Scheming.create name : 'string'`\n   - identifier - Function, returns true or false. Determines whether a value needs to be parsed.\n   - parser - Function, parses a value into the type.\n###\nTYPES =\n  String  :\n    ctor       : String\n    string     : 'string'\n    identifier : _.isString\n    parser     : (val) ->\n      '' + val\n    equals     : (a, b) -> a==b\n  Number  :\n    ctor       : Number\n    string     : 'number'\n    identifier : _.isNumber\n    parser     : parseFloat\n    comparator : (a, b) -> a==b\n    equals     : (a, b) -> a==b\n  Integer :\n    string     : 'integer'\n    identifier : (val) ->\n      _.isNumber(val) && val % 1 == 0\n    parser     : parseInt\n    equals     : (a, b) -> a==b\n  Date    :\n    ctor       : Date\n    string     : 'date'\n    identifier : _.isDate\n    parser     : (val) ->\n      new Date val\n    equals     : (a, b) -> a?.valueOf() == b?.valueOf()\n  Boolean :\n    ctor       : Boolean\n    string     : 'boolean'\n    identifier : _.isBoolean\n    parser     : (val) ->\n      !!val\n    equals     : (a, b) -> a==b\n  Mixed   :\n    ctor       : (val) ->\n      val\n    string     : '*'\n    identifier : ->\n      true\n    parser     : _.identity\n    equals     : (a, b) -> a==b\n\n# ### NESTED_TYPES\n###\n  Special type definitions for nested types. Used to identify and parse nested Arrays and Schemas.\n  Should not be extended or overridden.\n###\nNESTED_TYPES =\n  Array  :\n    ctor        : Array\n    string      : 'array'\n    identifier  : _.isArray\n    parser      : _.toArray\n    childType   : null\n    childParser : null\n    equals     : (a, b) -> _.isEqual a, b\n  Schema :\n    ctor       : Object\n    string     : 'schema'\n    identifier : null\n    parser     : null\n    childType  : null\n    equals     : (a, b) -> a == b\n\nTHROTTLE =\n  TIMEOUT : 'timeout'\n  IMMEDIATE : 'immediate'\n  ANIMATION_FRAME : 'animationFrame'\n\n_throttle = THROTTLE.TIMEOUT\n_queueCallback = null\n_resolveCallback = null\n\n# As listed by https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods\nARRAY_MUTATORS = ['copyWithin', 'fill', 'push', 'pop', 'reverse', 'shift', 'sort', 'splice', 'unshift']\n\n# Used internally to resolve a type declaration to its primitive type.\n# Matches a primitive type if it is...\n# - a reference to the object straight from the `Schema.TYPES` object\n# - a reference to the `ctor`\n# - a match with the type `string` (case insensitive)\ngetPrimitiveTypeOf = (type) ->\n  for k, TYPE of TYPES\n    if type == TYPE or\n        (TYPE.ctor && type == TYPE.ctor) or\n        type?.toLowerCase?() == TYPE.string\n\n      return TYPE\n\n  return null\n\n# Expose TYPES and DEFAULT_OPTIONS for extension and overriding\nScheming = {uuid, TYPES, NESTED_TYPES, DEFAULT_OPTIONS, THROTTLE}\n\n# ### setThrottle\n# Sets the throttling strategy that Scheming uses for resolving queued changes.\nScheming.setThrottle = (throttle) ->\n  if !_.contains THROTTLE, throttle\n    throw new Error \"Throttle option must be set to one of the strategies specified on Scheming.THROTTLE\"\n\n  switch throttle\n    when THROTTLE.TIMEOUT\n      _throttle = THROTTLE.TIMEOUT\n\n    when THROTTLE.IMMEDIATE\n      if setImmediate? && clearImmediate?\n        _throttle = THROTTLE.IMMEDIATE\n      else\n        console.warn \"Cannot use strategy IMMEDIATE: `setImmediate` or `clearImmediate` are not available in the current environment.\"\n\n    when THROTTLE.ANIMATION_FRAME\n      if requestAnimationFrame? && cancelAnimationFrame?\n        _throttle = THROTTLE.ANIMATION_FRAME\n      else\n        console.warn \"Cannot use strategy ANIMATION_FRAME: `requestAnimationFrame` or `cancelAnimationFrame` are not available in the current environment.\"\n\n# ### registerQueueCallback\n# registers a callback when the first Scheming change is queued with the change manager. This is useful for tests\nScheming.registerQueueCallback = (callback) ->\n  if !_.isFunction callback\n    throw new Error \"Callback must be a funtion\"\n  _queueCallback = callback\n\n# ### unregisterQueueCallback\n# unregisters a callback when the first Scheming change is queued with the change manager.\nScheming.unregisterQueueCallback = (callback) ->\n  _queueCallback = null\n\n# ### registerResolveCallback\n# registers a callback when the change manager is finished resolving changes\nScheming.registerResolveCallback = (callback) ->\n  if !_.isFunction callback\n    throw new Error \"Callback must be a funtion\"\n  _resolveCallback = callback\n\n# ### unregisterResolveCallback\n# unregisters a callback when the change manager is finished resolving changes\nScheming.unregisterResolveCallback = (callback) ->\n  _resolveCallback = null\n\n# ### resolveType\n# Resolves a type declaration to a primitive or nested type. Used internally when normalizing a schema.\nScheming.resolveType = (typeDef) ->\n  # - Attempt to resolve the type declaration to a primitive type\n  type = getPrimitiveTypeOf typeDef\n\n  if !type?\n    # - If the type definition is an array `[]`\n    if _.isArray typeDef\n      #   - Set the type to a clone of the array NESTED_TYPE\n      type = _.cloneDeep NESTED_TYPES.Array\n\n      #   - Recurse to resolve childType of array members\n      if typeDef.length\n        childType = Scheming.resolveType(typeDef[0])\n\n      #   - Throw an error if type is not explicitly declared\n      if !childType then throw new Error \"Error resolving type of array value #{typeDef}\"\n\n      type.childType = childType\n      #   - Write parser for child members of the array\n      type.childParser = (val) ->\n        for index, member of val\n          if !childType.identifier(member)\n            val[index] = childType.parser(member)\n\n        return val\n\n    # Function that builds identifier and parser for nested schema types. Needs to be factored out\n    # because nested schemas may be resolved lazily at a later time\n    resolveSchemaType = (type, childType) ->\n      type.childType = childType\n      type.identifier = (val) ->\n        return val instanceof childType\n      type.parser = (val) ->\n        return new childType(val)\n\n    ###\n    - If the type definition is an object `{}`\n      - Create a new Schema from the object\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isPlainObject typeDef\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = Scheming.create typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a reference to a Schema constructor\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isFunction(typeDef) && typeDef.__schemaId\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a string that begins with Schema:, such as `'Schema:Car'`\n      - It is assumed that the field is a reference to a nested Schema that will be registered with the name Car,\n    but may not be registered yet\n      - The Schema is not resolved immediately\n      - The parser and identifier functions are written as wrappers, so that the first time they are invoked the Schema\n    will be looked up at that time via `Scheming.get`, and real identifier and parser are set at that time.\n      - If the registered Schema cannot be resolved, throw an error.\n    ###\n    if _.isString(typeDef) && typeDef[...7] == 'Schema:'\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef[7..]\n      for fn in ['identifier', 'parser']\n        do (fn) ->\n          type[fn] = (val) ->\n            childType = Scheming.get childType\n            if !childType\n              throw new Error \"Error resolving #{typeDef} on lazy initialization\"\n            resolveSchemaType type, childType\n\n            return type[fn] val\n\n  return type || null\n\n# ### normalizePropertyConfig\n###\n  Normalizes a field declaration on a schema to capture type, default value, setter, getter, and validation.\n  Used internally when a schema is created to build a normalized schema definition.\n###\nScheming.normalizePropertyConfig = (propConfig, propName = 'field') ->\n  # initialize normalized property definition that we will return\n  definition =\n    type       : null\n    default    : null\n    getter     : null\n    setter     : null\n    validate   : null\n    required   : false\n\n  # if property configuration is not an object with a type key, assume that\n  # the configuration value is just the property type\n  if !(_.isPlainObject(propConfig) && propConfig.type?)\n    propConfig = {type : propConfig}\n\n  {type, getter, setter, validate, required} = propConfig\n  # This function throws errors on any bad configuration, attempting to fail fast.\n\n  # - Throw an error if type is not defined. Type must always be explicitly declared. Untyped fields\n  # must explicitly declared as Schema.TYPES.Mixed\n  if !type?\n    throw new Error \"Error resolving #{propName}. Schema type must be defined.\"\n  # - Throw an error if getter is not a function\n  if getter? && !_.isFunction getter\n    throw new Error \"Error resolving #{propName}. Schema getter must be a function.\"\n  # - Throw an error if setter is not a function\n  if setter? && !_.isFunction setter\n    throw new Error \"Error resolving #{propName}. Schema setter must be a function.\"\n\n  validate ?= []\n  # - If validate is a single function, transform to an array with one member\n  if !_.isArray(validate)\n    validate = [validate]\n  # - Check that all validate are a function, throw an error if it is not.\n  for fn in validate\n    if !_.isFunction fn\n      throw new Error \"Error resolving #{propName}. Schema validate must be a function or array of functions.\"\n\n  # - Resolve the declared type\n  definition.type = Scheming.resolveType type\n\n  # - If type could not be resolved, throw an error\n  if !definition.type?\n    throw new Error \"Error resolving #{propName}. Unrecognized type #{type}\"\n\n  # `default` is a reserved word, so we can't do the nice clean denatured assignment\n  definition.default = propConfig.default\n  definition.getter = getter\n  definition.setter = setter\n  definition.validate = validate\n  definition.required = required\n\n  # allow any custom properties to be exposed on the definition object\n  definition = _.extend {}, propConfig, definition\n\n  # Return a valid property configuration\n  return definition\n\n# Internal registry for schemas created by `Scheming.create`. Schemas are registered by their name, which is either\n# provided at time of creation, or generated as a uuid.\nregistry = {}\n\n# Used internally as part of `Scheming.create`, do not need to expose registration outside of Schema creation.\naddToRegistry = (key, value) ->\n  # Throw an error on naming collisions\n  if registry[key]\n    throw new Error \"Naming conflict encountered. Schema #{key} already exists\"\n  registry[key] = value\n\n# ### get\n# Retrieves a schema by registered name\nScheming.get = (name) ->\n  return registry[name]\n\n# ### reset\n# Resets the state of the Schema registry. Mainly exposed for testing, but could have use in production.\nScheming.reset = ->\n  registry = {}\n  _queueCallback = null\n  _resolveCallback = null\n\n# ### create\n# Creates a new Schema constructor\nScheming.create = (args...) ->\n  # If the first argument is a string, then the Schema is being named & registered. Otherwise, it is being\n  # created anonymously, and we need to give it a uuid for registration.\n  if !_.isString(args[0])\n    args.unshift uuid()\n\n  # Get name, config, and options from the create arguments\n  [name, schemaConfig, opts] = args\n\n  # Set options, defaulting to the Scheming.DEFAULT_OPTIONS\n  opts = _.defaults (opts || {}), DEFAULT_OPTIONS\n\n  # Build a new Schema\n  Schema = schemaFactory(name, opts)\n\n  # Define properties on the Schema based on the schema configuration\n  Schema.defineProperties schemaConfig\n\n  # Register the new Schema by the name provided or generated\n  addToRegistry name, Schema\n\n  return Schema\n\n# ## Schema\n# Factory method that builds Schema constructors\nschemaFactory = (name, opts) ->\n  # Normalized Schema is captured in closure\n  normalizedSchema = {}\n\n  class Schema\n    # __schemaId property references the schema name and identifies Schema constructors from any other function\n    @__schemaId       : name\n\n    # ### defineProperty\n    # Defines a property on the normalized schema, which is used at time of instance construction\n    @defineProperty   : (propName, propConfig) ->\n      normalizedSchema[propName] = Scheming.normalizePropertyConfig(propConfig, propName)\n\n    # ### defineProperties\n    # Convenience method for defining properties in bulk\n    @defineProperties : (config) ->\n      for k, v of config\n        @defineProperty k, v\n\n    # ### getProperties\n    # returns a clone of the normalized Schema\n    @getProperties : ->\n      return _.cloneDeep normalizedSchema\n\n    # ### getProperty\n    # returns a clone of the normalized Schema property\n    @getProperty : (propName) ->\n      return _.cloneDeep normalizedSchema[propName]\n\n    # ### eachProperty\n    # Iterates over each property name and configuration of the schema, invoking the provided callback\n    @eachProperty : (cb) ->\n      for propName, propConfig of normalizedSchema\n        cb propName, _.cloneDeep propConfig\n\n    # ### validate\n    # Run validation on an instance of the schema\n    @validate : (instance) ->\n      # Create errors hash that will be returned on any validation failure.\n      errors = {}\n\n      # Flag validating state to prevent infinite loop in the case of circular references\n      if instance._validating then return null\n      instance._validating = true\n\n      # Factored code to push error messages onto the errors hash\n      pushError = (key, err) ->\n        if _.isArray err\n          return pushError(key, e) for e in err\n        if !_.isString err\n          err = 'Validation error occurred.'\n        errors[key] ?= []\n        errors[key].push err\n\n      # Apply validation rules\n      for key, value of normalizedSchema\n        {validate, required} = value\n\n        # - Retrieve value. This will be affected by getters.\n        val = instance[key]\n\n        # - If the field is required and not defined, push the error and be done\n        if required && !val?\n          requiredMessage = if _.isString(required) then required else \"Field is required.\"\n          pushError key, requiredMessage\n        # - Only run validation on fields that are defined\n        if val?\n          {type} = normalizedSchema[key]\n\n          # - Run each validator on the field value\n          for validator in validate\n            err = true\n            # - Accept error strings that are returned, or errors that are thrown during processing\n            try\n              err = validator.call(instance, val)\n            catch e\n              if e then err = e.message\n            # - If any validation errors are detected, push them\n            if err != true then pushError key, err\n\n          # - Additionally, if the property is a nested schema, run its validation\n          if type.string == 'schema'\n            childErrors = type.childType.validate.call(instance, val)\n            for k, v of childErrors\n              #   - The key on the errors hash should be the path to the field that had a validation error\n              pushError \"#{key}.#{k}\", v\n          # - If the property is an array of schemas, run validation on each member of the array\n          if type.string == 'array' && type.childType.string == 'schema'\n            for member, i in val\n              childErrors = type.childType.childType.validate.call(instance, member)\n              for k, v of childErrors\n                #   - Again, the key on the errors hash should be the path to the field that had a validation error\n                pushError \"#{key}[#{i}].#{k}\", v\n\n        # Unset flag, indicating validation is complete\n      instance._validating = false\n\n      # Return null if no validation errros ocurred\n      if _.size(errors) == 0\n        return null\n      else\n        return errors\n\n    # ### constructor\n    # Constructor that builds instances of the Schema\n    constructor       : (initialState) ->\n\n      # turn `this` into a Schema instance\n      instanceFactory(@, normalizedSchema, initialState, opts)\n\n# ### Change Manager\n# Internal Change Manager class, responsible for queueing and resolving change event propagation for watches\nclass ChangeManager\n\n  constructor : ->\n    @changes = {}\n    @internalChangeQueue = []\n    @timeout = null\n\n    @recursionCount = 0\n\n  # reset the the change manager to a pristine state\n  reset : ->\n    @changes = {}\n    @internalChangeQueue = []\n    if @timeout?\n      _resolveCallback?()\n    @timeout = null\n\n    @recursionCount = 0\n\n  # Registers changes that have occurred on an instance by instance id, holding a reference to the original value\n  queueChanges : ({id, propName, oldVal, newVal, equals}, fireWatchers) ->\n    # if there are no changes yet queued for the instance, add to the changes hash by id\n    if !_.has @changes, id\n      @changes[id] ?= {changedProps : {}, fireWatchers}\n      @internalChangeQueue.push id\n    {changedProps} = @changes[id]\n\n    if propName\n      # if we are already tracking this property, and it has been reset to its original value, clear it from changes\n      if _.has(changedProps, propName) && equals(changedProps[propName], newVal)\n        delete changedProps[propName]\n      # if we are not tracking this property, and it is being changed, add it to changes\n      else if !_.has(changedProps, propName) && !equals(oldVal, newVal)\n        changedProps[propName] = oldVal\n\n    # Call the queue callback if a timeout hasn't been defined yet\n    if !@timeout?\n      _queueCallback?()\n\n    # Push the resolution step onto the event queue, once the thread has been released from\n    # a synchronous block of changes\n    switch _throttle\n      when THROTTLE.TIMEOUT\n        @timeout ?= setTimeout @resolve, 0\n      when THROTTLE.IMMEDIATE\n        @timeout ?= setImmediate @resolve\n      when THROTTLE.ANIMATION_FRAME\n        @timeout ?= requestAnimationFrame @resolve\n\n    # Keep a reference to the throttling strategy used so that flush will work if the strategy is changed\n    @_throttle = _throttle\n\n  # resolves queued changes, firing watchers on instances that have changed\n  resolve : =>\n    @recursionCount++\n    # track iteration count and throw an error after some limit to prevent infinite loops\n    if Scheming.ITERATION_LIMIT > 0 && @recursionCount > Scheming.ITERATION_LIMIT\n      changes = @changes\n      @reset()\n      # TODO: try to make a more meaningful error message from the instances (schema type, properties, etc)\n      throw new Error \"\"\"Aborting change propagation after #{Scheming.ITERATION_LIMIT} cycles.\n        This is probably indicative of a circular watch. Check the following watches for clues:\n        #{JSON.stringify(changes)}\"\"\"\n\n    # clear timeout to guarantee resolve is not called more than once.\n    switch @_throttle\n      when THROTTLE.TIMEOUT\n        clearTimeout @timeout\n      when THROTTLE.IMMEDIATE\n        clearImmediate @timeout\n      when THROTTLE.ANIMATION_FRAME\n        cancelAnimationFrame @timeout\n\n    # A single id may have been pushed to the change queue many times, to take a unique list of ids.\n    internalChanges = _.unique @internalChangeQueue\n    # Immediately reset the state of the change queue\n    @internalChangeQueue = []\n\n    # Fire internal watchers on all instances that have changed. This will cause the change event to propagate to\n    # any parent schemas, whose changes will populate `@internalChangeQueue`\n    for id in internalChanges\n      {changedProps, fireWatchers} = @changes[id]\n      fireWatchers changedProps, 'internal'\n    # if any new internal changes were registered, recursively call resolve to continue propagation\n    if @internalChangeQueue.length\n      return @resolve()\n\n    # Once internal watches have fired without causing a change on a parent schema instance, there are no more changes\n    # to propagate. At this point all changes on each instance have been aggregated into a single change set. Now\n    # fire all external watchers on each instance.\n    changes = @changes\n    # Immediately reset the change set\n    @changes = {}\n\n    # Fire all external watchers\n    for id of changes\n      {changedProps, fireWatchers} = changes[id]\n      fireWatchers changedProps, 'external'\n\n    # If any external watches caused new changes to be queued, re-run resolve to ensure propagation\n    if _.size(@changes) > 0\n      return @resolve()\n\n    # If we get here, all changes have been fully propagated. Reset change manager state to pristine just for explicitnessgit st\n    @reset()\n\n# set up global change manager that will be consumed by all schema instances\ncm = new ChangeManager\n\n# Configuration for limiting number of iterations\nScheming.ITERATION_LIMIT = 100\n\n# Synchronously cause the change manager resolve. Should be used for testing ONLY, to avoid having to write\n# asynchronous tests.\nScheming._flush = ->\n  console.warn \"`_flush` is being deprecated in favor of `flush`. Please switch usage over to the public method as `_flush` will be removed in a future release.\"\n  cm.resolve()\n\n# Synchronously cause the change manager resolve. May be used for testing to avoid asynchronous tests,\n# or may be used to force change resolution within client code.\nScheming.flush = ->\n  cm.resolve()\n\n# ## Instance\n# Factory method that builds accepts an object and turns it into a Schema instance\ninstanceFactory = (instance, normalizedSchema, initialState, opts)->\n  # flag to indicate initializing state of instance\n  _initializing = true\n  # data hash wrapped in closure, keeps actual data members private\n  data = {}\n  # private watchers array. External watches - those set by consuming client code - are tracked separately from\n  # internal watches - those to watch change propagation on nested schemas\n  watchers =\n    internal : []\n    external : []\n  # The unwatch functions from internal watches\n  unwatchers = {}\n\n  # Set an id on each instance that is not exposed, is used internally only for change management\n  id = uuid()\n\n  {strict, seal} = opts\n\n  # ### Property Setter\n  set = (propName, val) ->\n    prevVal = data[propName]\n\n    # if the property is not a part of the schema, simply set it on the instance.\n    # if the seal option is enabled this will fail silently, otherwise it will allow for arbitrary properties\n    if !normalizedSchema[propName]\n      return instance[propName] = val\n\n    # retrieve the type, getter, and setter from the normalized field config\n    {type, setter} = normalizedSchema[propName]\n\n    # - If a property is set to undefined, do not type cast or run through setter.\n    # You should always be able to clear a property.\n    if val?\n      # - If value is not undefined, run through type identifier to determine if it is the correct type\n      if !type.identifier(val)\n        #   - If not and strict mode is enabled, throw an error\n        if strict then throw new Error \"Error assigning #{val} to #{propName}. Value is not of type #{type.string}\"\n        #   - Otherwise, use parser to cast to the correct type\n        val = type.parser val\n      # - If the property type is of array, perform parsing on child members.\n      if type.string == NESTED_TYPES.Array.string\n        val = type.childParser val\n        # Overwrite mutator functions on this array to clone and assign instead of mutate. This guarantees\n        # that otherwise mutating changes are run through the setters and changes are captured.\n        _.each ARRAY_MUTATORS, (method) ->\n          if Array.prototype[method]?\n            Object.defineProperty val, method,\n              configurable : true\n              value : ->\n                clone = _.clone @\n                Array.prototype[method].call clone, arguments...\n                instance[propName] = clone\n\n      # - If a setter is defined, run the value through setter\n      if setter\n        val = setter.call instance, val\n\n    # - Assign to the data hash\n    data[propName] = val\n    # - If the value being assigned is of type schema, we need to listen for changes to propagate\n    watchForPropagation propName, val\n    # - Queue up a change to fire, unless you are setting the initial state of the instance\n    if !_initializing\n      cm.queueChanges {id, propName, oldVal : prevVal, newVal : val, equals : type.equals}, fireWatchers\n\n  # ### Property Getter\n  get = (propName) ->\n    # retrieve the type, getter, and setter from the normalized field config\n    {getter} = normalizedSchema[propName]\n\n    # - Retrieve data value from the hash\n    val = data[propName]\n    # - If getter is defined, run value through getter\n    if getter\n      val = getter.call instance, val\n    # - Finally, return the value\n    return val\n\n  # Adds a watcher to the instance\n  addWatcher = (properties, cb, opts) ->\n    # properties and opts arguments are optional\n    if _.isFunction properties\n      opts = cb\n      cb = properties\n      # if no properties are specified, the watcher is registered to watch all properties of the object\n      properties = _.keys normalizedSchema\n\n    # unless specified, a watch is assumed to be external. Clinet code should not set watches as internal!\n    # Behavior is undefined.\n    opts ?= {}\n    opts.internal ?= false\n\n    target = if opts.internal then 'internal' else 'external'\n\n    if !_.isFunction cb\n      throw new Error 'A watch must be provided with a callback function.'\n\n    # Cast the properties to an array. A watch can support one or more property names.\n    if properties && !_.isArray properties\n      properties = [properties]\n\n    # Throw an error if client code attempts to set a watch on a property that is not defined as part of the schema.\n    for propName in properties\n      if !_.has normalizedSchema, propName\n        throw new Error \"Cannot set watch on #{propName}, property is not defined in schema.\"\n\n    # Register the watcher on the correct internal or external watchers array. Flag new external watchers with `first`\n    # so that they will get called on the first change loop, regardless of whether the watch properties have changed.\n    # Internal watchers do not need to be invoked on first watch.\n    watcher = {properties, cb, first : !opts.internal}\n    watchers[target].push watcher\n\n    # Queue a change event on the change manager.\n    cm.queueChanges {id}, fireWatchers\n\n    # return an unwatch function\n    return ->\n      removeWatcher watcher, target\n\n  # Remove a watch listener from the appropraite watchers array\n  removeWatcher = (watcher, target) ->\n    _.remove watchers[target], watcher\n\n  # This function is called on value assignment\n  watchForPropagation = (propName, val) ->\n    {type} = normalizedSchema[propName]\n\n    # If the assigned property is of type schema, we need to listen for changes on the child instance to propagate\n    # changes to this instance\n    if type.string == NESTED_TYPES.Schema.string\n      # If there was a watcher from the previously assigned value, stop listening.\n      unwatchers[propName]?()\n      # Watch the new value for changes and propagate this changes to this instance. Flag the watch as internal.\n      unwatchers[propName] = val?.watch (newVal, oldVal)->\n        cm.queueChanges {id, propName, oldVal, newVal, equals: type.equals}, fireWatchers\n      , internal : true\n\n    # If the assigned property is an array of type schema, set a watch on each array memeber.\n    if type.string == NESTED_TYPES.Array.string and type.childType.string == NESTED_TYPES.Schema.string\n      # If there were watchers on the previous array members, clear those listeners.\n      for unwatcher in (unwatchers[propName] || [])\n        unwatcher?()\n      # reset the unwatchers array\n      unwatchers[propName] = []\n      # capture the old state of the array by cloning deep at time of assignment\n      oldArray = _.cloneDeep val\n      _.each val, (schema, i) ->\n        # set a new watch on each array member to propagate changes to this instance. Flag the watch as internal.\n        unwatchers[propName].push schema?.watch (newVal, oldVal)->\n          newArray = instance[propName]\n          oldArray[i] = oldVal\n          cm.queueChanges {id, propName, oldVal : oldArray, newVal : newArray, equals : type.equals}, fireWatchers\n        , internal : true\n\n  # Given a change set, fires all watchers that are watching one or more of the changed properties\n  fireWatchers = (queuedChanges, target='external') ->\n    triggeringProperties = _.keys queuedChanges\n\n    # Retrieves the previous value for a property, pulling from queued changes if present, otherwise retreiving\n    # current value - i.e. no change.\n    getPrevVal = (propName) ->\n      if _.has queuedChanges, propName\n        return queuedChanges[propName]\n      else\n        return instance[propName]\n\n    # for each registered watcher - use a while loop since firing one watcher can cause other watchers to be added or\n    # removed\n    i = 0\n    # TODO: there is a possible error here where firing one watcher removes another watcher from\n    # the array - the index would be off by one and a watcher could be skipped\n    while (watcher = watchers[target][i])\n      i++\n      # That watcher should fire if it is new, or if it is watching one or more of the changed properties\n      shouldFire = watcher.first || (_.intersection(triggeringProperties, watcher.properties).length > 0)\n      watcher.first = false\n      if shouldFire\n        newVals = {}\n        oldVals = {}\n\n        # build the hash of new / old values\n        for propName in watcher.properties\n          newVals[propName] = instance[propName]\n          oldVals[propName] = getPrevVal(propName)\n\n        # if the watcher is set against a single property, invoke the callback with the raw new / old values\n        if watcher.properties.length == 1\n          propName = watcher.properties[0]\n          newVals = newVals[propName]\n          oldVals = oldVals[propName]\n\n        try\n          watcher.cb newVals, oldVals\n        catch e\n          # TODO: browser support?\n          console.error e.stack || e\n\n  # ### watch\n  # Watches an instance for changes to one or more properties\n  Object.defineProperty instance, 'watch',\n    configurable : false\n    enumerable : false\n    writable : false\n    value : (properties, cb, opts) -> addWatcher properties, cb, opts\n\n  # Define a validating flag, which is used to prevent infinite loops on validation of circular references\n  Object.defineProperty instance, '_validating',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : false\n\n  # ### constructor\n  # for each property of the normalized schema\n  for propName, propConfig of normalizedSchema\n    do (propName, propConfig) =>\n      # define an enumerable property on the instance that is not configurable\n      # user get and set to manage getters, setters, and type parsing\n      Object.defineProperty instance, propName,\n        configurable : false\n        enumerable   : true\n        # **set**\n        set          : (val) -> set propName, val\n        # **get**\n        get          : -> get propName\n\n      # Once the property is configured, assign a default value. This ensures that default values are still\n      # affected by type parsing and setters\n      if propConfig.default != undefined\n        val = if _.isFunction(propConfig.default) then propConfig.default() else propConfig.default\n        instance[propName] = val\n\n  # If seal option is enabled, seal the instance, preventing addition of other properties besides those explicitly\n  # defined by the Schema\n  if seal\n    Object.seal instance\n\n  # set the initial state of the instance, then clear the initializing flag\n  for propName, val of initialState\n    instance[propName] = val\n\n  _initializing = false\n\n# All done. Export onto the correct root.\nif isNode\n  module.exports = Scheming\nelse\n  root.Scheming = Scheming\n"]}